/**
 * Authentication Error Handler Utilities
 * Provides comprehensive error handling for login and register flows
 */

// Error types for better categorization
export const AUTH_ERROR_TYPES = {
  VALIDATION: 'VALIDATION',
  NETWORK: 'NETWORK',
  SERVER: 'SERVER',
  AUTHENTICATION: 'AUTHENTICATION',
  AUTHORIZATION: 'AUTHORIZATION',
  TIMEOUT: 'TIMEOUT',
  UNKNOWN: 'UNKNOWN'
};

// Error messages mapping
export const AUTH_ERROR_MESSAGES = {
  // Network errors
  NETWORK_ERROR: 'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi internet.',
  TIMEOUT_ERROR: 'Y√™u c·∫ßu h·∫øt th·ªùi gian ch·ªù. Vui l√≤ng th·ª≠ l·∫°i.',
  CONNECTION_REFUSED: 'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server. Server c√≥ th·ªÉ ƒëang b·∫£o tr√¨.',
  
  // Authentication errors
  INVALID_CREDENTIALS: 'S·ªë ƒëi·ªán tho·∫°i ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng.',
  ACCOUNT_LOCKED: 'T√†i kho·∫£n ƒë√£ b·ªã kh√≥a. Vui l√≤ng li√™n h·ªá h·ªó tr·ª£.',
  ACCOUNT_DISABLED: 'T√†i kho·∫£n ƒë√£ b·ªã v√¥ hi·ªáu h√≥a.',
  TOKEN_EXPIRED: 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.',
  TOKEN_INVALID: 'Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá.',
  
  // Registration errors
  EMAIL_EXISTS: 'Email n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng.',
  PHONE_EXISTS: 'S·ªë ƒëi·ªán tho·∫°i n√†y ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω.',
  WEAK_PASSWORD: 'M·∫≠t kh·∫©u kh√¥ng ƒë·ªß m·∫°nh.',
  INVALID_EMAIL: 'Email kh√¥ng h·ª£p l·ªá.',
  INVALID_PHONE: 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá.',
  
  // Server errors
  SERVER_ERROR: 'L·ªói server. Vui l√≤ng th·ª≠ l·∫°i sau.',
  SERVICE_UNAVAILABLE: 'D·ªãch v·ª• t·∫°m th·ªùi kh√¥ng kh·∫£ d·ª•ng.',
  RATE_LIMITED: 'Qu√° nhi·ªÅu y√™u c·∫ßu. Vui l√≤ng th·ª≠ l·∫°i sau.',
  
  // Validation errors
  REQUIRED_FIELD: 'Tr∆∞·ªùng n√†y l√† b·∫Øt bu·ªôc.',
  INVALID_FORMAT: 'ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá.',
  MIN_LENGTH: 'T·ªëi thi·ªÉu {min} k√Ω t·ª±.',
  MAX_LENGTH: 'T·ªëi ƒëa {max} k√Ω t·ª±.',
  
  // Unknown errors
  UNKNOWN_ERROR: 'ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh. Vui l√≤ng th·ª≠ l·∫°i.'
};

/**
 * Parse error response from API
 * @param {Error} error - The error object
 * @returns {Object} Parsed error with type, message, and field errors
 */
export const parseAuthError = (error) => {
  console.log('üîç Parsing auth error:', error);
  
  // Default error structure
  const defaultError = {
    type: AUTH_ERROR_TYPES.UNKNOWN,
    message: AUTH_ERROR_MESSAGES.UNKNOWN_ERROR,
    fieldErrors: {},
    originalError: error
  };

  // Handle network/timeout errors
  if (error.code === 'ECONNABORTED' || error.message?.includes('timeout')) {
    return {
      ...defaultError,
      type: AUTH_ERROR_TYPES.TIMEOUT,
      message: AUTH_ERROR_MESSAGES.TIMEOUT_ERROR
    };
  }

  // Handle network errors
  if (error.code === 'ERR_NETWORK' || !error.response) {
    return {
      ...defaultError,
      type: AUTH_ERROR_TYPES.NETWORK,
      message: AUTH_ERROR_MESSAGES.NETWORK_ERROR
    };
  }

  // Handle server response errors
  if (error.response) {
    const { status, data } = error.response;
    
    // Handle different HTTP status codes
    switch (status) {
      case 400:
        return parseBadRequestError(data, defaultError);
      case 401:
        return {
          ...defaultError,
          type: AUTH_ERROR_TYPES.AUTHENTICATION,
          message: AUTH_ERROR_MESSAGES.INVALID_CREDENTIALS
        };
      case 403:
        return {
          ...defaultError,
          type: AUTH_ERROR_TYPES.AUTHORIZATION,
          message: AUTH_ERROR_MESSAGES.ACCOUNT_LOCKED
        };
      case 404:
        return {
          ...defaultError,
          type: AUTH_ERROR_TYPES.SERVER,
          message: 'Endpoint kh√¥ng t·ªìn t·∫°i.'
        };
      case 429:
        return {
          ...defaultError,
          type: AUTH_ERROR_TYPES.SERVER,
          message: AUTH_ERROR_MESSAGES.RATE_LIMITED
        };
      case 500:
      case 502:
      case 503:
      case 504:
        return {
          ...defaultError,
          type: AUTH_ERROR_TYPES.SERVER,
          message: AUTH_ERROR_MESSAGES.SERVER_ERROR
        };
      default:
        return parseServerError(data, defaultError);
    }
  }

  return defaultError;
};

/**
 * Parse 400 Bad Request errors
 */
const parseBadRequestError = (data, defaultError) => {
  const fieldErrors = {};
  let message = 'D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.';

  // Handle validation errors array
  if (data.errors && Array.isArray(data.errors)) {
    data.errors.forEach(error => {
      if (error.field) {
        fieldErrors[error.field] = error.message || AUTH_ERROR_MESSAGES.INVALID_FORMAT;
      }
    });
  }

  // Handle specific field errors
  if (data.email) fieldErrors.email = data.email;
  if (data.phone) fieldErrors.phone = data.phone;
  if (data.password) fieldErrors.password = data.password;
  if (data.fullName) fieldErrors.fullName = data.fullName;
  if (data.petName) fieldErrors.petName = data.petName;
  if (data.petType) fieldErrors.petType = data.petType;

  // Handle general message
  if (data.message) {
    message = parseErrorMessage(data.message);
  }

  return {
    ...defaultError,
    type: AUTH_ERROR_TYPES.VALIDATION,
    message,
    fieldErrors
  };
};

/**
 * Parse server error messages
 */
const parseServerError = (data, defaultError) => {
  let message = AUTH_ERROR_MESSAGES.SERVER_ERROR;

  if (data.message) {
    message = parseErrorMessage(data.message);
  } else if (data.error) {
    message = parseErrorMessage(data.error);
  }

  return {
    ...defaultError,
    type: AUTH_ERROR_TYPES.SERVER,
    message
  };
};

/**
 * Parse error message and map to Vietnamese
 */
const parseErrorMessage = (message) => {
  const lowerMessage = message.toLowerCase();

  // Email errors
  if (lowerMessage.includes('email') && lowerMessage.includes('already')) {
    return AUTH_ERROR_MESSAGES.EMAIL_EXISTS;
  }
  if (lowerMessage.includes('email') && lowerMessage.includes('invalid')) {
    return AUTH_ERROR_MESSAGES.INVALID_EMAIL;
  }

  // Phone errors
  if (lowerMessage.includes('phone') && lowerMessage.includes('already')) {
    return AUTH_ERROR_MESSAGES.PHONE_EXISTS;
  }
  if (lowerMessage.includes('phone') && lowerMessage.includes('invalid')) {
    return AUTH_ERROR_MESSAGES.INVALID_PHONE;
  }

  // Password errors
  if (lowerMessage.includes('password') && lowerMessage.includes('weak')) {
    return AUTH_ERROR_MESSAGES.WEAK_PASSWORD;
  }

  // Authentication errors
  if (lowerMessage.includes('invalid') && lowerMessage.includes('credentials')) {
    return AUTH_ERROR_MESSAGES.INVALID_CREDENTIALS;
  }
  if (lowerMessage.includes('account') && lowerMessage.includes('locked')) {
    return AUTH_ERROR_MESSAGES.ACCOUNT_LOCKED;
  }
  if (lowerMessage.includes('account') && lowerMessage.includes('disabled')) {
    return AUTH_ERROR_MESSAGES.ACCOUNT_DISABLED;
  }

  // Return original message if no mapping found
  return message;
};

/**
 * Validate form data
 * @param {Object} formData - Form data to validate
 * @param {Object} rules - Validation rules
 * @returns {Object} Validation result with errors
 */
export const validateFormData = (formData, rules) => {
  const errors = {};

  Object.keys(rules).forEach(field => {
    const value = formData[field];
    const fieldRules = rules[field];

    // Required validation
    if (fieldRules.required && (!value || value.toString().trim() === '')) {
      errors[field] = AUTH_ERROR_MESSAGES.REQUIRED_FIELD;
      return;
    }

    // Skip other validations if field is empty and not required
    if (!value || value.toString().trim() === '') return;

    // Length validation
    if (fieldRules.minLength && value.length < fieldRules.minLength) {
      errors[field] = AUTH_ERROR_MESSAGES.MIN_LENGTH.replace('{min}', fieldRules.minLength);
      return;
    }

    if (fieldRules.maxLength && value.length > fieldRules.maxLength) {
      errors[field] = AUTH_ERROR_MESSAGES.MAX_LENGTH.replace('{max}', fieldRules.maxLength);
      return;
    }

    // Pattern validation
    if (fieldRules.pattern && !fieldRules.pattern.test(value)) {
      errors[field] = fieldRules.message || AUTH_ERROR_MESSAGES.INVALID_FORMAT;
      return;
    }

    // Custom validation
    if (fieldRules.custom && !fieldRules.custom(value)) {
      errors[field] = fieldRules.message || AUTH_ERROR_MESSAGES.INVALID_FORMAT;
      return;
    }
  });

  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

/**
 * Validation rules for different forms
 */
export const VALIDATION_RULES = {
  LOGIN: {
    phone: {
      required: true,
      pattern: /^[0-9]{10,15}$/,
      message: 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i c√≥ 10-15 ch·ªØ s·ªë.'
    },
    password: {
      required: true,
      minLength: 6,
      message: 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±.'
    }
  },
  REGISTER: {
    fullName: {
      required: true,
      minLength: 2,
      maxLength: 50,
      message: 'H·ªç t√™n ph·∫£i c√≥ 2-50 k√Ω t·ª±.'
    },
    email: {
      required: true,
      pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      message: 'Email kh√¥ng h·ª£p l·ªá.'
    },
    phone: {
      required: true,
      pattern: /^[0-9]{10,15}$/,
      message: 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i c√≥ 10-15 ch·ªØ s·ªë.'
    },
    password: {
      required: true,
      minLength: 8,
      custom: (value) => {
        // At least 8 characters, 1 uppercase, 1 lowercase, 1 number or special char
        return /^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9!@#$%^&*(),.?":{}|<>]).{8,}$/.test(value);
      },
      message: 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 8 k√Ω t·ª±, bao g·ªìm ch·ªØ hoa, ch·ªØ th∆∞·ªùng v√† s·ªë ho·∫∑c k√Ω t·ª± ƒë·∫∑c bi·ªát.'
    },
    petName: {
      required: true,
      minLength: 1,
      maxLength: 30,
      message: 'T√™n th√∫ c∆∞ng ph·∫£i c√≥ 1-30 k√Ω t·ª±.'
    },
    petType: {
      required: true,
      message: 'Vui l√≤ng ch·ªçn lo·∫°i th√∫ c∆∞ng.'
    }
  }
};

/**
 * Check password strength
 * @param {string} password - Password to check
 * @returns {Object} Password strength indicators
 */
export const checkPasswordStrength = (password) => {
  const strength = {
    hasMinLength: password.length >= 8,
    hasUppercase: /[A-Z]/.test(password),
    hasLowercase: /[a-z]/.test(password),
    hasNumber: /[0-9]/.test(password),
    hasSpecialChar: /[!@#$%^&*(),.?":{}|<>]/.test(password),
    score: 0
  };

  // Calculate strength score
  strength.score = Object.values(strength).filter(Boolean).length - 1; // -1 for score itself

  return strength;
};

/**
 * Format error for display
 * @param {Object} error - Error object
 * @returns {Object} Formatted error for UI
 */
export const formatErrorForDisplay = (error) => {
  return {
    type: error.type,
    message: error.message,
    fieldErrors: error.fieldErrors,
    timestamp: new Date().toISOString()
  };
};

